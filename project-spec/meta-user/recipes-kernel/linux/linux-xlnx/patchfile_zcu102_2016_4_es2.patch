From 5cdb9931a658fc00c1703fec0966cd81535ac353 Mon Sep 17 00:00:00 2001
From: Benjamin Bimmermann <b.bimmermann@yahoo.de>
Date: Sun, 20 Aug 2017 14:26:55 +0200
Subject: [PATCH] Qsim specific changes to the linux kernel

* Enable qsim to track process pids
* Enable qsim to track CPU boot
---
 arch/arm64/include/asm/mmu_context.h |  6 +++++-
 arch/arm64/kernel/smp.c              |  8 ++++++--
 arch/x86/kernel/smpboot.c            | 10 ++++++++++
 kernel/sched/core.c                  | 19 +++++++++++++++++++
 4 files changed, 40 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h
index b1892a0..663e21a 100644
--- a/arch/arm64/include/asm/mmu_context.h
+++ b/arch/arm64/include/asm/mmu_context.h
@@ -29,6 +29,8 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 
+extern void do_cpuid(uint32_t val);
+
 #ifdef CONFIG_PID_IN_CONTEXTIDR
 static inline void contextidr_thread_switch(struct task_struct *next)
 {
@@ -36,7 +38,9 @@ static inline void contextidr_thread_switch(struct task_struct *next)
 	"	msr	contextidr_el1, %0\n"
 	"	isb"
 	:
-	: "r" (task_pid_nr(next)));
+	: "r" (task_tgid_nr(next)));
+
+	do_cpuid(0xc75c0000 | (u16)task_tgid_nr(next));
 }
 #else
 static inline void contextidr_thread_switch(struct task_struct *next)
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index b2d5f4e..17a84d5 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -91,10 +91,14 @@ static inline int op_cpu_kill(unsigned int cpu)
  */
 static int boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
+	int ret = -EOPNOTSUPP;
 	if (cpu_ops[cpu]->cpu_boot)
-		return cpu_ops[cpu]->cpu_boot(cpu);
+		ret = cpu_ops[cpu]->cpu_boot(cpu);
 
-	return -EOPNOTSUPP;
+	if (ret != -EOPNOTSUPP)
+		asm("msr pmcr_el0, %0\n"::"r"(cpu | 0xb0070000));
+
+	return ret;
 }
 
 static DECLARE_COMPLETION(cpu_running);
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 0e4329e..d5f81f6 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -692,11 +692,19 @@ wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip)
 	return (send_status | accept_status);
 }
 
+/* Use magic instruction to boot other CPUs. */
+static inline void QSIM_BOOTSTRAP(u16 cpu)
+{
+	asm volatile("mov %0, %%eax;\n cpuid;\n" :: "r"(0xb0070000 | cpu) :
+		     "%eax", "%ebx", "%edx", "%ecx");
+}
+
 static int
 wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 {
 	unsigned long send_status = 0, accept_status = 0;
 	int maxlvt, num_starts, j;
+	static u16 cur_cpu = 1;
 
 	maxlvt = lapic_get_maxlvt();
 
@@ -734,6 +742,8 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 	pr_debug("Waiting for send to finish...\n");
 	send_status = safe_apic_wait_icr_idle();
 
+	QSIM_BOOTSTRAP(cur_cpu++);
+
 	mb();
 
 	/*
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index d1f7149..95cbb57 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2708,6 +2708,16 @@ asmlinkage __visible void schedule_tail(struct task_struct *prev)
 		put_user(task_pid_vnr(current), current->set_child_tid);
 }
 
+void do_cpuid(uint32_t val)
+{
+#if defined(__aarch64__)
+	asm volatile("msr pmcr_el0, %0" :: "r" (val));
+#else
+	asm("cpuid;\n":: "a"(val) : "%ebx", "%ecx", "%edx");
+#endif
+}
+EXPORT_SYMBOL(do_cpuid);
+
 /*
  * context_switch - switch to the new MM and the new thread's register state.
  */
@@ -2717,6 +2727,15 @@ context_switch(struct rq *rq, struct task_struct *prev,
 {
 	struct mm_struct *mm, *oldmm;
 
+	/* tell qsim the pid of the next task or that it is idle
+	 */
+	if (IS_ENABLED(CONFIG_X86) || IS_ENABLED(CONFIG_ARM64)) {
+		if (next == rq->idle)
+			do_cpuid(0x1d1e1d1e);
+		else
+			do_cpuid(0xc75c0000 | (u16)task_tgid_nr(next));
+	}
+
 	prepare_task_switch(rq, prev, next);
 
 	mm = next->mm;
-- 
2.7.4

